---
title: Understanding Sum-Check Protocol
aside:
  toc: false
tags:
  - algebra
  - cs 
---


> Taken from: [Oleg Fomenko and Anton Levochko: Understanding Lasso - A Novel Lookup Argument Protocol](https://eprint.iacr.org/2025/1169)

A sum-check protocol [^Lund] is an interactive proof protocol used in
theoretical computer science to verify the correctness of a sum of values computed by a multivariate polynomial over a
finite field, assuming oracle access to the polynomial. It allows a verifier to check a complex computation (like a huge
sum over exponentially many values) using only a few rounds of interaction and logarithmic work.

Let $g$ be an $\ell$-variate polynomial over a finite field $\mathbb{F}$. The goal of the sum-check protocol is
for the verifier $\mathcal{V}$ to check that the prover $\mathcal{P}$ has correctly computed:

$$
H := \sum_{b \in \{0,1\}^\ell} g(b)
$$

We assume that $\mathcal{V}$ has oracle access to the polynomial $g \in \mathbb{F}^\ell[x]$. The protocol proceeds
as follows:

1. **Initialization:**
   $\mathcal{P}$ sends a claimed value $C_1 = H$ to $\mathcal{V}$.

2. **First Round:**
   $\mathcal{P}$ sends a univariate polynomial:

   $$
   g_1(X_1) = \sum_{(x_2,\dots,x_\ell) \in \{0,1\}^{\ell-1}} g(X_1, x_2, \dots, x_\ell)
   $$

   $\mathcal{V}$ checks that:

    * $C_1 = g_1(0) + g_1(1)$
    * $\deg(g_1) \le \deg_1(g)$

3. **Verifier Samples:**
   $\mathcal{V}$ picks a random $r_1 \in \mathbb{F}$ and sends it to $\mathcal{P}$.

4. **Intermediate Rounds (for $2 \le j < \ell$):**
   $\mathcal{P}$ sends:

   $$
   g_j(X_j) = \sum_{(x_{j+1},\dots,x_\ell) \in \{0,1\}^{\ell-j}} g(r_1, \dots, r_{j-1}, X_j, x_{j+1}, \dots, x_\ell)
   $$

   $\mathcal{V}$ checks:

    * $\deg(g_j) \le \deg_j(g)$
    * $g_{j-1}(r_{j-1}) = g_j(0) + g_j(1)$

   Then samples $r_j \in \mathbb{F}$ and sends it to $\mathcal{P}$.

5. **Final Round:**
   $\mathcal{P}$ sends:

   $$
   g_\ell(X_\ell) = g(r_1, \dots, r_{\ell-1}, X_\ell)
   $$

   $\mathcal{V}$ checks:

    * $\deg(g_\ell) \le \deg_\ell(g)$
    * $g_{\ell-1}(r_{\ell-1}) = g_\ell(0) + g_\ell(1)$

6. **Final Query and Check:**
   $\mathcal{V}$ picks $r_\ell \in \mathbb{F}$ and queries the oracle for $g(r_1, \dots, r_\ell)$. Then checks:

   $$
   g_\ell(r_\ell) = g(r_1, \dots, r_\ell)
   $$

7. **Accept:**
   If all checks pass, $\mathcal{V}$ accepts. Otherwise, it rejects.

## Sum-Check Protocol (with Commitment)

### Oracle Query Procedure

Used to open committed values via any multilinear polynomial commitment protocol commitments.

```text
Query(C_f âˆˆ ð”½, x âˆˆ {0,1}^â„“)

// Executed by both ð’« and ð’±
ð’« computes (f(x), Ï€) â† Open(C_f, x)
ð’± executes Verify(C_f, x, f(x), Ï€)
Return f(x)
```

### Algorithm

Executed by both prover $\mathcal{P}$ and verifier $\mathcal{V}$ for polynomial $g$, its commitment $C_g$, and
claimed sum $H$:

```text
SumCheckProtocol(H âˆˆ ð”½, g: {0,1}^â„“ â†’ ð”½, C_g âˆˆ ð”½)

Set gâ‚(Xâ‚) = âˆ‘_{(xâ‚‚,â€¦,x_â„“) âˆˆ {0,1}^{â„“-1}} g(Xâ‚,xâ‚‚,â€¦,x_â„“)
ð’« shares gâ‚ with ð’±
ð’± evaluates gâ‚(0), gâ‚(1)
If H â‰  gâ‚(0) + gâ‚(1): ð’± rejects
ð’± samples râ‚ âˆˆ ð”½, evaluates gâ‚(râ‚)

For j = 2 to â„“:
    Set gâ±¼(Xâ±¼) = âˆ‘_{(x_{j+1},â€¦,x_â„“)} g(râ‚,â€¦,r_{jâˆ’1},Xâ±¼,x_{j+1},â€¦,x_â„“)
    ð’« shares gâ±¼ with ð’±
    ð’± evaluates gâ±¼(0), gâ±¼(1)
    If gâ±¼â‚‹â‚(râ±¼â‚‹â‚) â‰  gâ±¼(0) + gâ±¼(1): ð’± rejects
    ð’± samples râ±¼ âˆˆ ð”½, evaluates gâ±¼(râ±¼)

ð’± calls Query(C_g, (râ‚,â€¦,r_â„“)) to get g(râ‚,â€¦,r_â„“)
If g_â„“(r_â„“) â‰  g(râ‚,â€¦,r_â„“): ð’± rejects
```

### Remark

Sometimes, $g$ is not committed directly, but rather defined as a known combination of other committed polynomials.
**In such cases, we override the query/commit methods by committing to and querying these polynomials individually, then
combining them according to the predefined structure.**

[^Lund]: Carsten Lund et al. â€œAlgebraic Methods for Interactive Proof Systemsâ€. In: Journal of the ACM 39.4 (Oct. 1992), pp. 859â€“868. doi: 10.1145/146585.146605.
